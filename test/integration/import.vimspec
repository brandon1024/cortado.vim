Describe Import
	After
		%bwipeout!
	End

	Describe #JavaImportKeyword
		It should sort imports if no classname provided and no keyword under cursor
			edit! test/input/Simple.java

			" position the cursor at the end of the file so that <cword> expands
			" to empty string
			call cursor(line('$'), 0)

			" sanity check
			Assert Equals(expand('<cword>'), '')

			call java_support#import#JavaImportKeyword()

			let l:import_lines = java_support#buffer#FindLinesMatchingPattern('%', 1, '^import')
			Assert Equals(len(l:import_lines), 2)

			" should have sorted
			Assert Equals(l:import_lines[0], 'import ca.example.vim.external.Interface;')
			Assert Equals(l:import_lines[1], 'import ca.example.vim.internal.ImportedClass;')
		End
	End

	Describe #FindUnused
		Before
			call setqflist([], 'r')
		End

		It should find unused imports and add them to the quickfix list
			edit! test/input/FindUnusedImports.java

			call java_support#import#FindUnused()

			let l:errors = getqflist()
			Assert Equals(len(l:errors), 1)

			let l:error = l:errors[0]
			Assert Equals(l:error['pattern'], 'ca.example.vim.internal.Unused')
			Assert Equals(l:error['text'], 'ca.example.vim.internal.Unused')

			let l:tree = java_support#import_tree#BuildFromBuffer()
			Assert True(test_utils#tree#HasNode(l:tree, 'ca.example.vim.internal.Unused'))
		End

		It should remove unused imports
			edit! test/input/FindUnusedImports.java

			call java_support#import#FindUnused('%', v:true)
			
			Assert True(empty(getqflist()))

			let l:tree = java_support#import_tree#BuildFromBuffer()
			Assert False(test_utils#tree#HasNode(l:tree, 'ca.example.vim.internal.Unused'))
		End
	End

	Describe #ResultComparator
		It should sort results by kind
			let l:results = [
				\ { 'type': 'indexed', 'val': 9 },
				\ { 'type': 'c', 'val': 0 },
				\ { 'type': 'm', 'val': 8 },
				\ { 'type': 'c', 'val': 1 },
				\ { 'type': 'e', 'val': 6 },
				\ { 'type': 'g', 'val': 5 },
				\ { 'type': 'e', 'val': 7 },
				\ { 'type': 'a', 'val': 4 },
				\ { 'type': 'i', 'val': 3 },
				\ { 'type': 'indexed', 'val': 10 },
				\ { 'type': 'unknown', 'val': 11 },
				\ { 'type': 'c', 'val': 2 },
			\ ]

			let l:sorted = sort(l:results, function('java_support#import#ResultComparator'))
			for i in range(len(l:results))
				Assert Equals(l:sorted[i]['val'], i)
			endfor
		End
	End

	Describe #MergeFilterDuplicateResults
		It should filter indexed results that exist in the tag results
			let l:results = [
				\ { 'fq_name': ['com', 'example', 'vim'] },
				\ { 'fq_name': ['com', 'example', 'vim1'] },
			\ ]
			let l:index_results = [
				\ { 'fq_name': ['com', 'example', 'vim1'] },
			\ ]

			let l:filtered = java_support#import#MergeFilterDuplicateResults(l:results, l:index_results)
			Assert Equals(len(l:filtered), 2)
			for i in range(len(l:filtered))
				Assert Equals(l:filtered[i].fq_name, l:results[i].fq_name)
			endfor
		End
	End
End

