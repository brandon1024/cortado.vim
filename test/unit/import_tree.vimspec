Describe import_tree
	Describe #BuildFromBuffer
		Before
			%bwipeout!
		End

		It should remove import statements from the buffer if arg is true
			edit! test/input/StaticImports.java

			call java_support#import_tree#BuildFromBuffer('%', v:true)
			let l:lines = java_support#buffer#FindLinesMatchingPattern('%', 1, 'import')
			Assert Equal(len(l:lines), 0)
		End

		It should not remove import statements from the buffer if arg is false
			edit! test/input/StaticImports.java

			call java_support#import_tree#BuildFromBuffer()
			let l:lines = java_support#buffer#FindLinesMatchingPattern('%', 1, 'import')
			Assert True(len(l:lines) > 0)
		End

		It should correctly build an import tree from the statements in the buffer
			edit! test/input/StaticImports.java

			let l:tree = java_support#import_tree#BuildFromBuffer('%', v:true)
			Assert True(test_utils#tree#HasNode(l:tree, 'java.io.IOException'))
			Assert True(test_utils#tree#HasNode(l:tree, 'java.util.List'))
			Assert True(test_utils#tree#HasNode(l:tree, 'java.util.Collections'))
			Assert True(test_utils#tree#HasNode(l:tree, 'ca.example.vim.internal.ImportedClass'))
			Assert True(test_utils#tree#HasNode(l:tree, 'ca.example.vim.external.Interface'))
			Assert True(test_utils#tree#HasNode(l:tree, 'javax.servlet.FilterChain'))
		End

		It should correctly build an import tree from the statements in a provided buffer
			edit test/input/StaticImports.java
			vsp test/input/ImportStaticMethod.java

			let l:tree = java_support#import_tree#BuildFromBuffer('test/input/StaticImports.java')
			Assert True(test_utils#tree#HasNode(l:tree, 'ca.example.vim.Util.staticMethod'))
		End
	End

	Describe #MergeFromBuffer
		Before
			%bwipeout!
		End

		It should merge import statements from the given buffer into an existing tree
			edit test/input/StaticImports.java
			vsp test/input/ImportStaticMethod.java

			let l:tree = java_support#import_tree#BuildFromBuffer('test/input/StaticImports.java')
			let l:tree = java_support#import_tree#MergeFromBuffer(l:tree, 'test/input/ImportStaticMethod.java')

			" should have nodes from both buffers
			Assert True(test_utils#tree#HasNode(l:tree, 'java.io.IOException'))
			Assert True(test_utils#tree#HasNode(l:tree, 'ca.example.vim.Util.staticMethod'))
		End
	End

	Describe #BuildFromStatements
		It should correctly build an import from the given statements
			let l:statements = [
					\ 'import javax.servlet.FilterChain;',
					\ 'import java.util.Collections;',
					\ 'import java.util.List;'
				\ ]

			let l:tree = java_support#import_tree#BuildFromStatements(l:statements)
			Assert True(test_utils#tree#HasNode(l:tree, 'javax.servlet.FilterChain'))
			Assert True(test_utils#tree#HasNode(l:tree, 'java.util.List'))
			Assert True(test_utils#tree#HasNode(l:tree, 'java.util.Collections'))
		End

		It should correctly set metadata for static imports
			let l:stmt = 'import static ca.example.vim.Util.staticMethod;'
			let l:tree = java_support#import_tree#BuildFromStatements([l:stmt])

			Assert True(test_utils#tree#HasNode(l:tree, 'ca.example.vim.Util.staticMethod'))
			let [_, l:meta] = test_utils#tree#GetMetadataForNode(l:tree, 'ca.example.vim.Util.staticMethod')
			Assert True(has_key(l:meta, 's'))
			Assert True(l:meta.s)
		End

		It should correctly set metadata for non-static imports
			let l:stmt = 'import java.util.List;'
			let l:tree = java_support#import_tree#BuildFromStatements([l:stmt])

			Assert True(test_utils#tree#HasNode(l:tree, 'java.util.List'))
			let [_, l:meta] = test_utils#tree#GetMetadataForNode(l:tree, 'java.util.List')
			Assert True(has_key(l:meta, 's'))
			Assert False(l:meta.s)
		End

		It should create a tree with the correct internal structure
			let l:stmt = 'import java.util.List;'
			let l:tree = java_support#import_tree#BuildFromStatements([l:stmt])

			" level 1
			Assert True(has_key(l:tree, 'children'))
			Assert True(has_key(l:tree, 'leaf'))
			Assert False(len(l:tree.leaf))

			" children at level 1
			Assert Equal(len(l:tree.children), 1)
			Assert True(has_key(l:tree.children, 'java'))

			" level 2
			Assert True(has_key(l:tree.children.java, 'children'))
			Assert True(has_key(l:tree.children.java, 'leaf'))
			Assert False(len(l:tree.children.java.leaf))

			" children at level 2
			Assert Equal(len(l:tree.children.java.children), 1)
			Assert True(has_key(l:tree.children.java.children, 'util'))

			" level 3
			Assert True(has_key(l:tree.children.java.children.util, 'children'))
			Assert True(has_key(l:tree.children.java.children.util, 'leaf'))
			Assert Equal(len(l:tree.children.java.children.util.children), 0)

			" leafs at level 3
			Assert Equal(len(l:tree.children.java.children.util.leaf), 1)
			Assert True(has_key(l:tree.children.java.children.util.leaf, 'List'))
		End

		It should filter whitespace properly
			let l:stmt = '     import 	 java  . util.List   ; '
			let l:tree = java_support#import_tree#BuildFromStatements([l:stmt])
			Assert True(test_utils#tree#HasNode(l:tree, 'java.util.List'))
		End

		It should split compound statements
			let l:stmt = 'import javax.servlet.FilterChain; import java.util.Collections;'
			let l:tree = java_support#import_tree#BuildFromStatements([l:stmt])

			Assert True(test_utils#tree#HasNode(l:tree, 'java.util.Collections'))
			Assert True(test_utils#tree#HasNode(l:tree, 'javax.servlet.FilterChain'))
		End

		It should correctly insert wildcard imports
			let l:stmt = 'import java.util.*;'
			let l:tree = java_support#import_tree#BuildFromStatements([l:stmt])

			Assert True(test_utils#tree#HasNode(l:tree, 'java.util.*'))
		End
	End

	Describe #MergeFromStatements
		It should correctly merge statements into an existing tree
			let l:statements = [
					\ 'import javax.servlet.FilterChain;',
					\ 'import java.util.Collections;',
					\ 'import java.util.List;'
				\ ]

			let l:tree = java_support#import_tree#BuildFromStatements(l:statements)
			let l:tree = java_support#import_tree#MergeFromStatements(l:tree, ['import ca.example.MyClass'])
			Assert True(test_utils#tree#HasNode(l:tree, 'javax.servlet.FilterChain'))
			Assert True(test_utils#tree#HasNode(l:tree, 'java.util.List'))
			Assert True(test_utils#tree#HasNode(l:tree, 'java.util.Collections'))
			Assert True(test_utils#tree#HasNode(l:tree, 'ca.example.MyClass'))
		End
	End

	Describe #BuildFromFile
		It should build a tree from the given file path
			let l:tree = java_support#import_tree#BuildFromFile('test/input/ImportStaticMethod.java')
			Assert True(test_utils#tree#HasNode(l:tree, 'ca.example.vim.internal.ImportedClass'))
			Assert True(test_utils#tree#HasNode(l:tree, 'ca.example.vim.external.Interface'))
		End
	End

	Describe #MergeFromFile
		It should merge imports from a file path into an existing tree
			let l:statements = [
					\ 'import javax.servlet.FilterChain;',
					\ 'import java.util.Collections;',
					\ 'import java.util.List;'
				\ ]

			let l:tree = java_support#import_tree#BuildFromStatements(l:statements)
			let l:tree = java_support#import_tree#MergeFromFile(l:tree, 'test/input/ImportStaticMethod.java')

			Assert True(test_utils#tree#HasNode(l:tree, 'javax.servlet.FilterChain'))
			Assert True(test_utils#tree#HasNode(l:tree, 'java.util.List'))
			Assert True(test_utils#tree#HasNode(l:tree, 'java.util.Collections'))
			Assert True(test_utils#tree#HasNode(l:tree, 'ca.example.vim.internal.ImportedClass'))
			Assert True(test_utils#tree#HasNode(l:tree, 'ca.example.vim.external.Interface'))
		End
	End

	Describe #BuildEmpty
		It should build an empty tree with correct structure
			let l:tree = java_support#import_tree#BuildEmpty()
			Assert True(has_key(l:tree, 'children'))
			Assert False(len(l:tree.children))
			Assert True(has_key(l:tree, 'leaf'))
			Assert False(len(l:tree.leaf))
		End
	End

	Describe #Merge
		Before
			%bwipeout!
		End

		It should insert a fully-qualified entity into the tree
			edit! test/input/Simple.java

			let l:tree = java_support#import_tree#BuildFromBuffer(v:false)
			call java_support#import_tree#Merge(l:tree, ['com', 'example', 'vim', 'thing'])

			Assert True(test_utils#tree#HasNode(l:tree, 'com.example.vim.thing'))
		End

		It should create the tree node with the given metadata
			edit! test/input/Simple.java

			let l:tree = java_support#import_tree#BuildFromBuffer(v:false)
			call java_support#import_tree#Merge(l:tree, ['com', 'example', 'vim', 'thing'], { 'my-metadata': v:true })

			Assert True(test_utils#tree#HasNode(l:tree, 'com.example.vim.thing'))
			let [_, l:meta] = test_utils#tree#GetMetadataForNode(l:tree, 'com.example.vim.thing')
			
			Assert True(has_key(l:meta, 'my-metadata'))
			Assert Equals(l:meta['my-metadata'], v:true)
		End
	End

	Describe #MergeTrees
		It should merge two trees into a single tree
			let l:tree_a = java_support#import_tree#BuildFromFile('test/input/StaticImports.java')
			let l:tree_b = java_support#import_tree#BuildFromFile('test/input/StaticImports.java')
			
			let l:tree = java_support#import_tree#MergeTrees(l:tree_a, l:tree_b)

			Assert True(test_utils#tree#HasNode(l:tree, 'java.io.IOException'))
			Assert True(test_utils#tree#HasNode(l:tree, 'java.util.List'))
			Assert True(test_utils#tree#HasNode(l:tree, 'java.util.Collections'))
			Assert True(test_utils#tree#HasNode(l:tree, 'ca.example.vim.internal.ImportedClass'))
			Assert True(test_utils#tree#HasNode(l:tree, 'ca.example.vim.external.Interface'))
			Assert True(test_utils#tree#HasNode(l:tree, 'javax.servlet.FilterChain'))
			Assert True(test_utils#tree#HasNode(l:tree, 'ca.example.vim.Util.staticMethod'))
		End
	End

	Describe #Flatten
		Before
			%bwipeout!
		End

		After
			let g:java_import_wildcard_count = 0
		End

		It should flatten a simple tree to a list of unique identifiers
			let l:statements = [
					\ 'import javax.servlet.FilterChain;',
					\ 'import java.util.Collections;',
					\ 'import java.util.List;',
					\ 'import java.util.List;'
				\ ]

			let l:tree = java_support#import_tree#BuildFromStatements(l:statements)
			let l:result = java_support#import_tree#Flatten(l:tree)
			
			Assert Equals(len(l:result), 3)
			Assert True(index(l:result, 'javax.servlet.FilterChain') >= 0)
			Assert True(index(l:result, 'java.util.Collections') >= 0)
			Assert True(index(l:result, 'java.util.List') >= 0)
		End

		It should prepend the prefix to each returned value
			let l:tree = java_support#import_tree#BuildFromStatements(['import javax.servlet.FilterChain;'])
			let l:result = java_support#import_tree#Flatten(l:tree, { 'prefix': '$' })
			
			Assert Equals(len(l:result), 1)
			Assert True(index(l:result, '$javax.servlet.FilterChain') >= 0)
		End

		It should append the postfix to each returned value
			let l:tree = java_support#import_tree#BuildFromStatements(['import javax.servlet.FilterChain;'])
			let l:result = java_support#import_tree#Flatten(l:tree, { 'postfix': '$' })
			
			Assert Equals(len(l:result), 1)
			Assert True(index(l:result, 'javax.servlet.FilterChain$') >= 0)
		End

		It should correctly filter elements by their metadata if configured
			let l:statements = [
					\ 'import javax.servlet.FilterChain;',
					\ 'import static java.util.Collections;',
					\ 'import java.util.List;'
				\ ]

			" with static filter
			let l:tree = java_support#import_tree#BuildFromStatements(l:statements)
			let l:result = java_support#import_tree#Flatten(l:tree, { 'filter': { 's': v:true } })
			
			Assert Equals(len(l:result), 1)
			Assert True(index(l:result, 'java.util.Collections') >= 0)

			" now with non-static
			let l:result = java_support#import_tree#Flatten(l:tree, { 'filter': { 's': v:false } })
			
			Assert Equals(len(l:result), 2)
			Assert True(index(l:result, 'java.util.List') >= 0)
			Assert True(index(l:result, 'javax.servlet.FilterChain') >= 0)
		End

		It should use the provided initial list if configured
			let l:initial = ['test123']
			let l:tree = java_support#import_tree#BuildFromStatements(['import javax.servlet.FilterChain;'])
			let l:result = java_support#import_tree#Flatten(l:tree, { 'initial': l:initial })
			
			Assert Equals(len(l:result), 2)
			Assert True(index(l:result, 'javax.servlet.FilterChain') >= 0)
			Assert True(index(l:result, l:initial[0]) >= 0)
		End

		It should remove wildcard nodes if configured
			let g:java_import_wildcard_count = -1

			let l:statements = [
					\ 'import javax.servlet.FilterChain;',
					\ 'import java.util.Collections;',
					\ 'import java.util.List;',
					\ 'import java.util.*;'
				\ ]

			let l:tree = java_support#import_tree#BuildFromStatements(l:statements)
			let l:result = java_support#import_tree#Flatten(l:tree)
			
			Assert Equals(len(l:result), 3)
			Assert True(index(l:result, 'javax.servlet.FilterChain') >= 0)
			Assert True(index(l:result, 'java.util.Collections') >= 0)
			Assert True(index(l:result, 'java.util.List') >= 0)
		End

		It should merge leafs into wildcard nodes if configured
			let g:java_import_wildcard_count = 0

			let l:statements = [
					\ 'import javax.servlet.FilterChain;',
					\ 'import java.util.Collections;',
					\ 'import java.util.List;',
					\ 'import java.util.*;'
				\ ]

			let l:tree = java_support#import_tree#BuildFromStatements(l:statements)
			let l:result = java_support#import_tree#Flatten(l:tree)
			
			Assert Equals(len(l:result), 2)
			Assert True(index(l:result, 'javax.servlet.FilterChain') >= 0)
			Assert True(index(l:result, 'java.util.*') >= 0)
		End

		It should merge leafs nodes into wildcards if the number of leafs exceed configured value
			let g:java_import_wildcard_count = 3

			let l:statements = [
					\ 'import javax.servlet.FilterChain;',
					\ 'import java.util.Collections;',
					\ 'import java.util.List;',
					\ 'import java.util.Arrays;'
				\ ]

			let l:tree = java_support#import_tree#BuildFromStatements(l:statements)
			let l:result = java_support#import_tree#Flatten(l:tree)
			
			Assert Equals(len(l:result), 2)
			Assert True(index(l:result, 'javax.servlet.FilterChain') >= 0)
			Assert True(index(l:result, 'java.util.*') >= 0)

			let l:statements = [
					\ 'import javax.servlet.FilterChain;',
					\ 'import java.util.Collections;',
					\ 'import java.util.List;'
				\ ]

			let l:tree = java_support#import_tree#BuildFromStatements(l:statements)
			let l:result = java_support#import_tree#Flatten(l:tree)
			
			Assert Equals(len(l:result), 3)
			Assert True(index(l:result, 'javax.servlet.FilterChain') >= 0)
			Assert True(index(l:result, 'java.util.Collections') >= 0)
			Assert True(index(l:result, 'java.util.List') >= 0)
		End

		It should throw if options has an unexpected key
			let l:tree = java_support#import_tree#BuildFromStatements([])
			Throws /not a supported option/ java_support#import_tree#Flatten(l:tree, { '_path': [] })
		End
	End

	Describe #Remove
		It should not remove nodes that do not exist in tree
			let l:statements = [
					\ 'import javax.servlet.FilterChain;',
					\ 'import java.util.Collections;',
					\ 'import java.util.List;'
				\ ]

			let l:tree = java_support#import_tree#BuildFromStatements(l:statements)

			let l:removed = java_support#import_tree#Remove(l:tree, ['java', 'util', 'Collection'])
			Assert False(l:removed)

			let l:removed = java_support#import_tree#Remove(l:tree, ['java', 'util', 'List', 'Deeper'])
			Assert False(l:removed)
		End

		It should correctly remove node from the tree
			let l:statements = [
					\ 'import javax.servlet.FilterChain;',
					\ 'import java.util.Collections;',
					\ 'import java.util.List;',
					\ 'import java.util.List.Deeper;'
				\ ]

			let l:tree = java_support#import_tree#BuildFromStatements(l:statements)

			let l:removed = java_support#import_tree#Remove(l:tree, ['java', 'util', 'List'])
			Assert True(l:removed)
			Assert False(test_utils#tree#HasNode(l:tree, 'java.util.List'))
			Assert True(test_utils#tree#HasNode(l:tree, 'java.util.List.Deeper'))
		End
	End

	Describe #Index
		It should flatten tree into a dictionary keyed by leaf name
			let l:statements = [
					\ 'import javax.servlet.FilterChain;',
					\ 'import java.util.Collections;',
					\ 'import java.util.List;'
				\ ]

			let l:tree = java_support#import_tree#BuildFromStatements(l:statements)
			let l:indexed_tree = java_support#import_tree#Index(l:tree)

			Assert True(has_key(l:indexed_tree, 'FilterChain'))
			Assert Equals(len(l:indexed_tree['FilterChain']), 1)
			Assert Equals(l:indexed_tree['FilterChain'][0]['fq_name'], ['javax', 'servlet', 'FilterChain'])

			Assert True(has_key(l:indexed_tree, 'Collections'))
			Assert Equals(len(l:indexed_tree['Collections']), 1)
			Assert Equals(l:indexed_tree['Collections'][0]['fq_name'], ['java', 'util', 'Collections'])

			Assert True(has_key(l:indexed_tree, 'List'))
			Assert Equals(len(l:indexed_tree['List']), 1)
			Assert Equals(l:indexed_tree['List'][0]['fq_name'], ['java', 'util', 'List'])
		End

		It should combine entries with matching leaf name
			let l:statements = [
					\ 'import java.util.Collections;',
					\ 'import org.library.Collections;'
				\ ]

			let l:tree = java_support#import_tree#BuildFromStatements(l:statements)
			let l:indexed_tree = java_support#import_tree#Index(l:tree)

			Assert True(has_key(l:indexed_tree, 'Collections'))
			Assert Equals(len(l:indexed_tree['Collections']), 2)
			Assert Equals(l:indexed_tree['Collections'][0]['fq_name'], ['org', 'library', 'Collections'])
			Assert Equals(l:indexed_tree['Collections'][1]['fq_name'], ['java', 'util', 'Collections'])
		End
	End
End

